{ Message, TextMessage } = require.main.require 'hubot'
SlackClient = require './client'
Promise = require 'bluebird'

class ReactionMessage extends Message
  # Represents a message generated by an emoji reaction event
  #
  # type      - A String indicating 'reaction_added' or 'reaction_removed'
  # user      - A User instance that reacted to the item.
  # reaction  - A String identifying the emoji reaction.
  # item_user - A String indicating the user that posted the item.
  # item      - An Object identifying the target message, file, or comment item.
  # event_ts  - A String of the reaction event timestamp.
  constructor: (@type, @user, @reaction, @item_user, @item, @event_ts) ->
    super @user
    @type = @type.replace('reaction_', '')

class SlackTextMessage extends TextMessage

  @MESSAGE_REGEX =  ///
    <              # opening angle bracket
    ([@#!])?       # link type
    ([^>|]+)       # link
    (?:\|          # start of |label (optional)
    ([^>]+)        # label
    )?             # end of label
    >              # closing angle bracket
  ///g

  @MESSAGE_RESERVED_KEYWORDS = ['channel','group','everyone','here']

  # Represents a TextMessage created from the Slack adapter
  #
  # user       - The User object
  # text       - The parsed message text
  # rawText    - The unparsed message text
  # rawMessage - The Slack Message object
  constructor: (@user, text, rawText, @rawMessage, channel, robot_name, client) ->
    # private instance properties (not trying to expand API contract)
    @_channel = channel
    @_robot_name = robot_name
    @_client = client    

    # public instance property initialization
    @rawText = if rawText? then rawText else @rawMessage.text
    @text = if text? then text else undefined # else @buildText()
    @thread_ts = @rawMessage.thread_ts if @rawMessage.thread_ts?

    super @user, @text, @rawMessage.ts

  ###*
  # Build the text property, a flat string representation of the contents of this message.
  ###
  buildText: (cb) ->
    # base text
    text = @rawMessage.text

    # flatten any attachments into text
    if @rawMessage.attachments
      attachment_text = @rawMessage.attachments.map(a => a.fallback).join('\n')
      text = text + '\n' + attachment_text

    # Replace links in text async to fetch user and channel info (if present)
    @replaceLinks(text).then((replacedText) =>

      text = replacedText
      text = text.replace /&lt;/g, '<'
      text = text.replace /&gt;/g, '>'
      text = text.replace /&amp;/g, '&'

      if @_channel?.is_im
        text = "#{@_robot_name} #{text}"     # If this is a DM, pretend it was addressed to us

      @text = text

      cb()
    )

  ###*
  # Replace links inside of text
  ###
  replaceLinks: (text) ->
    parts = []
    cursor = 0
    regex = SlackTextMessage.MESSAGE_REGEX
    regex.lastIndex = 0

    while (res = regex.exec(text))
      [m, type, link, label] = res

      switch type
        when '@'
          if label
            parts.push(text.slice(cursor, res.index), "@#{label}")
          else
            parts.push(text.slice(cursor, res.index), @replaceUser.apply(null, [link, @_client]))
        
        when '#'
          if label
            parts.push(text.slice(cursor, res.index), "\##{label}")
          else
            parts.push(text.slice(cursor, res.index), @replaceChannel.apply(null, [link, @_client]))

        when '!'
          if link in SlackTextMessage.MESSAGE_RESERVED_KEYWORDS
            parts.push(text.slice(cursor, res.index), "@#{link}")
          else if label
            parts.push(text.slice(cursor, res.index), label)
          else
            parts.push(text.slice(cursor, res.index), m)

        else
          link = link.replace /^mailto:/, ''
          if label and -1 == link.indexOf label
            parts.push(text.slice(cursor, res.index), "#{label} #{link}")
          else
            parts.push(text.slice(cursor, res.index), link)

      cursor = regex.lastIndex
      if (res[0].length == 0) 
        regex.lastIndex++

    parts.push text.slice(cursor)

    return Promise.all(parts).then((substrings) ->
      return substrings.join('')
    )

  ###*
  # Returns name of user with id
  ###
  replaceUser: (id, client) ->
    return client.web.users.info(id).then((user) -> user.name)

  ###*
  # Returns name of channel with id
  ###
  replaceChannel: (id, client) ->
    return client.web.channel.info(id).then((channel) -> channel.name)

  ###*
  # Factory method to construct SlackTextMessage
  ###
  @makeSlackTextMessage: (@user, text, rawText, @rawMessage, channel, robot_name, client, cb) ->
    message = new SlackTextMessage(@user, text, rawText, @rawMessage, channel, robot_name, client)

    if not message.text? then message.buildText(() =>
      cb(message)
    ) else cb(message)

exports.SlackTextMessage = SlackTextMessage
exports.ReactionMessage = ReactionMessage
