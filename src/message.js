const {Message, TextMessage}  = require.main.require("hubot/es2015.js");
const SlackClient = require("./client");
const SlackMention = require("./mention");

class ReactionMessage extends Message {

  /**
   * Represents a message generated by an emoji reaction event
   *
   * @constructor
   * @param {string} type - A String indicating 'reaction_added' or 'reaction_removed'
   * @param {User} user - A User instance that reacted to the item.
   * @param {string} reaction - A String identifying the emoji reaction.
   * @param {Object} item - An Object identifying the target message, file, or comment item.
   * @param {User} [item_user] - A String indicating the user that posted the item. If the item was created by a
   * custom integration (not part of a Slack app with a bot user), then this value will be undefined.
   * @param {string} event_ts - A String of the reaction event timestamp.
   */
  constructor(type, user, reaction, item_user, item, event_ts) {
    super(user);
    this.type = type;
    this.user = user;
    this.reaction = reaction;
    this.item_user = item_user;
    this.item = item;
    this.event_ts = event_ts;
    this.type = this.type.replace("reaction_", "");
  }
}
    
class FileSharedMessage extends Message {

  /**
   * Represents a message generated by an file_shared event
   *
   * @constructor
   * @param {User} user - A User instance that reacted to the item.
   * @param {string} file_id - A String identifying the file_id of the file that was shared.
   * @param {string} event_ts - A String of the file_shared event timestamp.
   */
  constructor(user, file_id, event_ts) {
    super(user);
    this.user = user;
    this.file_id = file_id;
    this.event_ts = event_ts;
  }
}

class MeMessage extends TextMessage {

  /**
   * Represents a message generated by a /me invocation
   *
   * @constructor
   * @param {User} user - A User instance that created the /me message
   * @param {string} text - Text of the /me message
   * @param {string} event_ts - event timestamp
   */
  constructor(user, text, event_ts) {
    this.user = user;
    this.text = text;
    this.event_ts = event_ts;
    super(this.user, this.text, this.event_ts);
  }
}

class PresenceMessage extends Message {

  /**
   * Represents a message generated by a presence change event
   *
   * @constructor
   * @param {Array<User>} users - Array of users that changed their status
   * @param {string} presence - Status is either 'active' or 'away'
   */
  constructor(users, presence) {
    // supply the super class with a fake user because the real data is in the `users` property
    super({ room: "" });
    this.users = users;
    this.presence = presence;
  }
}

class SlackTextMessage extends TextMessage {
  /**
   * Represents a TextMessage created from the Slack adapter
   *
   * @constructor
   * @param {User} user - The User who sent this message
   * @param {string|undefined} text - The parsed message text. Its no longer recommended to use this property.
   * The `buildText()` method can be used to parse the raw text and populate the `text` property.
   * @param {string|undefined} rawText - The unparsed message text. Its no longer recommended to use this property.
   * The constructor will default to the `rawMessage.text` value.
   * @param {Object} rawMessage - The Slack Message object
   * @param {string} rawMessage.text
   * @param {string} rawMessage.ts
   * @param {string} [rawMessage.thread_ts] - the identifier for the thread the message is a part of
   * @param {string} [rawMessage.attachments] - Slack message attachments
   * @param {string} channel_id - The conversation where this message was sent.
   * @param {string} robot_name - The Slack username for this robot
   * @param {string} robot_alias - The alias for this robot
   */
  constructor(user, text, rawText, rawMessage, channel_id, robot_name, robot_alias) {
    super(user, text, rawMessage.ts);
    // private instance properties
    this.user = user;
    this.text = text;
    this.rawMessage = rawMessage;
    this._channel_id = channel_id;
    this._robot_name = robot_name;
    this._robot_alias = robot_alias;

    // public instance property initialization
    this.rawText = rawText || this.rawMessage.text;
    if (this.rawMessage.thread_ts != null) { this.thread_ts = this.rawMessage.thread_ts; }
    this.mentions = [];          
  }
  static MESSAGE_REGEX =  new RegExp(`\
<\
([@#!])?\
([^>|]+)\
(?:\\|\
([^>]+)\
)?\
>\
`, 'g');
  static MESSAGE_RESERVED_KEYWORDS = ["channel","group","everyone","here"];

  /**
   * Build the text property, a flat string representation of the contents of this message.
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {function} cb - callback for the result
   */
  buildText(client, cb) {
    // base text
    let text = (this.rawMessage.text != null) ? this.rawMessage.text : "";

    // flatten any attachments into text
    if (this.rawMessage.attachments) {
      const attachment_text = this.rawMessage.attachments.map(a => a.fallback).join("\n");
      if (attachment_text.length > 0) { text = text + "\n" + attachment_text; }
    }

    // Replace links in text async to fetch user and channel info (if present)
    const mentionFormatting = this.replaceLinks(client, text);
    // Fetch conversation info
    const fetchingConversationInfo = client.fetchConversation(this._channel_id);
    return Promise.all([mentionFormatting, fetchingConversationInfo])
      .then(results => {
        const [ replacedText, conversationInfo ] = results;
        text = replacedText;
        text = text.replace(/&lt;/g, "<");
        text = text.replace(/&gt;/g, ">");
        text = text.replace(/&amp;/g, "&");

        // special handling for message text when inside a DM conversation
        if (conversationInfo.is_im) {
          const startOfText = text.indexOf("@") === 0 ? 1 : 0;
          const robotIsNamed = (text.indexOf(this._robot_name) === startOfText) || (text.indexOf(this._robot_alias) === startOfText);
          // Assume it was addressed to us even if it wasn't
          if (!robotIsNamed) {
            text = `${this._robot_name} ${text}`;     // If this is a DM, pretend it was addressed to us
          }
        }

        this.text = text;
        return cb();
    }).catch(error => {
        client.robot.logger.error(`An error occurred while building text: ${error.message}`);
        return cb(error);
    });
  }

  /**
   * Replace links inside of text
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @returns {Promise<string>}
   */
  replaceLinks(client, text) {
    let result;
    const regex = SlackTextMessage.MESSAGE_REGEX;
    regex.lastIndex = 0;
    let cursor = 0;
    const parts = [];

    while (result = regex.exec(text)) {
      var [m, type, link, label] = result;

      switch (type) {
        case "@":
          if (label) {
            parts.push(text.slice(cursor, result.index), `@${label}`);
            this.mentions.push(new SlackMention(link, "user", undefined));
          } else {
            parts.push(text.slice(cursor, result.index), this.replaceUser(client, link, this.mentions));
          }
          break;

        case "#":
          if (label) {
            parts.push(text.slice(cursor, result.index), `\#${label}`);
            this.mentions.push(new SlackMention(link, "conversation", undefined));
          } else {
            parts.push(text.slice(cursor, result.index), this.replaceConversation(client, link, this.mentions));
          }
          break;

        case "!":
          if (SlackTextMessage.MESSAGE_RESERVED_KEYWORDS.includes(link)) {
            parts.push(text.slice(cursor, result.index), `@${link}`);
          } else if (label) {
            parts.push(text.slice(cursor, result.index), label);
          } else {
            parts.push(text.slice(cursor, result.index), m);
          }
          break;

        default:
          link = link.replace(/^mailto:/, "");
          if (label && (-1 === link.indexOf(label))) {
            parts.push(text.slice(cursor, result.index), `${label} (${link})`);
          } else {
            parts.push(text.slice(cursor, result.index), link);
          }
      }

      cursor = regex.lastIndex;
      if (result[0].length === 0) {
        regex.lastIndex++;
      }
    }

    parts.push(text.slice(cursor));

    return Promise.all(parts)
      .then(substrings => substrings.join(""));
  }

  /**
   * Creates a mention from a user ID
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {string} id - the user ID
   * @param {Array<Mention>} mentions - a mentions array that is updated to include this user mention
   * @returns {Promise<string>} - a string that can be placed into the text for this mention
   */
  replaceUser(client, id, mentions) {
    return client.fetchUser(id)
      .then(res => {
        mentions.push(new SlackMention(res.id, "user", res));
        return `@${res.name}`;
    }).catch(error => {
        client.robot.logger.error(`Error getting user info ${id}: ${error.message}`);
        return `<@${id}>`;
    });
  }

  /**
   * Creates a mention from a conversation ID
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {string} id - the conversation ID
   * @param {Array<Mention>} mentions - a mentions array that is updated to include this conversation mention
   * @returns {Promise<string>} - a string that can be placed into the text for this mention
   */
  replaceConversation(client, id, mentions) {
    return client.fetchConversation(id)
      .then(conversation => {
        if (conversation != null) {
          mentions.push(new SlackMention(conversation.id, "conversation", conversation));
          return `\#${conversation.name}`;
        } else { return `<\#${id}>`; }
    }).catch(error => {
        client.robot.logger.error(`Error getting conversation info ${id}: ${error.message}`);
        return `<\#${id}>`;
    });
  }

  /**
   * Factory method to construct SlackTextMessage
   * @public
   * @param {User} user - The User who sent this message
   * @param {string|undefined} text - The parsed message text. Its no longer recommended to use this property.
   * The `buildText()` method can be used to parse the raw text and populate the `text` property.
   * @param {string|undefined} rawText - The unparsed message text. Its no longer recommended to use this property.
   * The constructor will default to the `rawMessage.text` value.
   * @param {Object} rawMessage - The Slack Message object
   * @param {string} rawMessage.text
   * @param {string} rawMessage.ts
   * @param {string} [rawMessage.thread_ts] - the identifier for the thread the message is a part of
   * @param {string} [rawMessage.attachments] - Slack message attachments
   * @param {string} channel_id - The conversation where this message was sent.
   * @param {string} robot_name - The Slack username for this robot
   * @param {string} robot_alias - The alias for this robot
   * @param {SlackClient} client - client used to fetch more data
   * @param {function} cb - callback to return the result
   */
  static makeSlackTextMessage(user, text, rawText, rawMessage, channel_id, robot_name, robot_alias, client, cb) {
    const message = new SlackTextMessage(user, text, rawText, rawMessage, channel_id, robot_name, robot_alias);

    // creates a completion function that consistently calls the callback after this function has returned
    const done = message => setImmediate(() => cb(null, message));

    if ((message.text == null)) {
      return message.buildText(client, function(error) {
        if (error) {
          return cb(error);
        }
        return done(message);
      });
    } else {
      return done(message);
    }
  }
}

exports.SlackTextMessage = SlackTextMessage;
exports.ReactionMessage = ReactionMessage;
exports.PresenceMessage = PresenceMessage;
exports.FileSharedMessage = FileSharedMessage;
exports.MeMessage = MeMessage;